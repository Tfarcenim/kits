plugins {
    id 'java'
    id 'idea'
    id 'maven-publish'
    id 'fabric-loom'
    id 'checkstyle'
    id 'com.modrinth.minotaur' version '2.+'
    id 'com.matthewprenger.cursegradle' version '1.4.0'
    id "com.github.breadmoirai.github-release" version "2.3.7"
}
base {
    archivesName = "${mod_name}-fabric-${minecraft_version}"
}
dependencies {
    implementation group: 'com.google.code.findbugs', name: 'jsr305', version: '3.0.1'
    implementation project(":common")

    // Fabric
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings loom.layered() {
        officialMojangMappings()
        parchment("org.parchmentmc.data:parchment-$minecraft_version:$parch_mapping@zip")
    }
    modImplementation "net.fabricmc:fabric-loader:${fabric_loader_version}"

    // Mods
    modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"
    modImplementation "me.lucko:fabric-permissions-api:${project.permissions_api_version}"
    modImplementation include("eu.pb4:sgui:${project.sgui_version}")

    // Code Quality
    compileOnly "org.jetbrains:annotations:${project.jetbrains_annotations_version}"
    testImplementation "org.junit.jupiter:junit-jupiter-api:${project.junit_jupiter_version}"
    testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${project.junit_jupiter_version}"

    // JiJ Dependencies
    modApi  "me.lucko:fabric-permissions-api:${project.permissions_api_version}"
    include "me.lucko:fabric-permissions-api:${project.permissions_api_version}"
    modApi("me.shedaniel.cloth:cloth-config-fabric:$cloth_config_version") {
        exclude(module: "fabric-api")
    }


    include("me.shedaniel.cloth:cloth-config-fabric:$cloth_config_version") {
        exclude(module: "fabric-api")
    }

    modApi("org.jetbrains:annotations:19.0.0")
    modCompileOnly("com.terraformersmc:modmenu:$modmenu_version") {
        transitive(false)
    }
    modRuntimeOnly("com.terraformersmc:modmenu:$modmenu_version") {
        transitive(false)
    }

}

loom {
    if (project(":common").file("src/main/resources/${mod_id}.accesswidener").exists()) {
        accessWidenerPath.set(project(":common").file("src/main/resources/${mod_id}.accesswidener"))
    }
    mixin {
        defaultRefmapName.set("${mod_id}.refmap.json")
    }
    runs {
        client {
            client()
            setConfigName("Fabric Client")
            ideConfigGenerated(true)
            runDir("run")
        }
        server {
            server()
            setConfigName("Fabric Server")
            ideConfigGenerated(true)
            runDir("run")
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    source(project(":common").sourceSets.main.allSource)
}
tasks.withType(Javadoc).configureEach {
    source(project(":common").sourceSets.main.allJava)
}
tasks.named("sourcesJar", Jar) {
    from(project(":common").sourceSets.main.allSource)
}

processResources {
    from project(":common").sourceSets.main.resources
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifactId base.archivesName.get()
            from components.java
        }
    }
    repositories {
        maven {
            url "file://" + System.getenv("local_maven")
        }
    }
}

ext.env = loadenv()

String getenv(String key) {
    return env.getOrDefault(key, "NOT FOUND")
}

tasks.withType(JavaCompile).configureEach {
    // ensure that the encoding is set to UTF-8, no matter what the system default is
    // this fixes some edge cases with special characters not displaying correctly
    // see http://yodaconditions.net/blog/fix-for-java-file-encoding-problems-with-gradle.html
    // If Javadoc is generated, this must be specified in that task too.
    it.options.encoding = "UTF-8"

    // Minecraft 1.18 upwards uses Java 17.
    it.options.release.set(17)
}

configurations.all {
    resolutionStrategy {
        force("net.fabricmc:fabric-loader:$fabric_loader_version")
    }
}

// Define how artifacts are published to Modrinth (https://modrinth.com)
import com.modrinth.minotaur.TaskModrinthUpload
import com.modrinth.minotaur.request.VersionType

modrinth {
    token = getenv("MODRINTH") // An environment property called MODRINTH that is your token, set via Gradle CLI, GitHub Actions, Idea Run Configuration, or other
    projectId = project.mr_project_id
    versionNumber = project.version // Will fail if Modrinth has this version already
    versionType = project.version.contains('alpha') ? VersionType.ALPHA.toString()
        : project.version.contains('beta') ? VersionType.BETA.toString()
        : VersionType.RELEASE.toString()

    // On fabric, use 'remapJar' instead of 'jar'

    uploadFile = remapJar
    // This is the java jar task. If it can't find the jar, try 'jar.outputs.getFiles().asPath' in place of 'jar'
    gameVersions = List.of(project.mr_game_versions.split(','))
    changelog = readChangelogFromFile()
    loaders = ['fabric']

//    dependencies = {
//        var requiredMods = (project.mr_relations_required).split(',').collect { new ModDependency(it, DependencyType.REQUIRED)}
//        var optionalMods = (project.mr_relations_optional).split(',').collect { new ModDependency(it, DependencyType.OPTIONAL)}
//        var incompatibleMods = (project.mr_relations_incompatible).split(',').collect { new ModDependency(it, DependencyType.INCOMPATIBLE)}
//
//        var outList = new ArrayList<ModDependency>(requiredMods.size() + optionalMods.size() + incompatibleMods.size())
//        outList.addAll(requiredMods)
//        outList.addAll(optionalMods)
//        outList.addAll(incompatibleMods)
//        return outList
//    }()
}

task publishModrinth(type: TaskModrinthUpload) { // Make sure it runs after build!
    description 'Uploads all Modrinth projects'
    group 'upload'

    onlyIf {
        // Only attempt to run this task if the MODRINTH variable is set in .env, otherwise SKIP it
        env.containsKey("MODRINTH")
    }
}
// Define how artifacts are published to CurseForge (https://curseforge.com)
curseforge {
    apiKey = getenv("CURSEFORGE")

    // Declare all projects
    //noinspection GroovyAssignabilityCheck
    project {
        // Set the project id
        id = project.cf_project_id
        // Set the release type
        releaseType = project.version.contains('alpha') ? 'alpha'
            : project.version.contains('beta') ? 'beta'
            : 'release'
        // Set the release notes
        changelog = "For a list of changes, please refer to https://github.com/${project.github_repo}/releases/tag/${project.version}"
        // Add all supported game versions
        project.cf_game_versions.split(',').each { addGameVersion it }
        // Add the main artifact
        mainArtifact(remapJar) { displayName = "${project.version}" }

        // Add any additional artifacts
        subprojects.each {
            addArtifact it.remapJar
//            addArtifact it.sourcesJar
//            addArtifact it.jar
        }
        // Add any dependencies
        relations {
            if (project.cf_relations_required) project.cf_relations_required.split(',').each { requiredDependency it }
            if (project.cf_relations_optional) project.cf_relations_optional.split(',').each { optionalDependency it }
            if (project.cf_relations_embedded) project.cf_relations_embedded.split(',').each { embeddedLibrary it }
            if (project.cf_relations_tools) project.cf_relations_tools.split(',').each { tool it }
            if (project.cf_relations_incompatible) project.cf_relations_incompatible.split(',').each { incompatible it }
        }
    }

    // Configure other options
    options {
        forgeGradleIntegration = false
    }
}

tasks.getByName("githubRelease").each { task -> configure(task) {
    description 'Creates a GitHub Release for the project'
    group 'upload'
    onlyIf {
        env.containsKey("GITHUB")
    }
}}
githubRelease {
    token = getenv("GITHUB") // This is your personal access token with Repo permissions
    // You get this from your user settings > developer settings > Personal Access Tokens
    owner = project.gh_owner // default is the last part of your group. Eg group: "com.github.breadmoirai" => owner: "breadmoirai"
    repo = project.gh_repo // by default this is set to your project name
    tagName = project.version as String // by default this is set to "v${project.version}"
    targetCommitish = "1.20.1" // by default this is set to "master"
    releaseName = project.version as String // Release title, by default this is the same as the tagName
    body = readChangelogFromFile() // by default this is empty
    draft = false // by default this is false
    prerelease = false // by default this is false
    releaseAssets libsDirectory
        .getAsFileTree()
        .matching((PatternFilterable pattern) -> pattern.include("**/*${project.version}.jar"))
    //jar.outputs.getFiles().asPath//
    overwrite = false // by default false; if set to true, will delete an existing release with the same tag and name
    dryRun = false // by default false; you can use this to see what actions would be taken without making a release
    apiEndpoint = "https://api.github.com" // should only change for github enterprise users
    client // This is the okhttp client used for http requests
    allowUploadToExisting = false
}

// Define how packages are published
publishing {
    // Declare all publications
    publications {
        mavenJava(MavenPublication) {
            // Main
            artifact(remapJar) { builtBy remapJar }
            // Sources
            artifact(sourcesJar) { builtBy remapSourcesJar }
        }
    }

    // Add repositories to publish to
    repositories {
        // GitHub Packages (https://pkg.github.com)
        maven {
            name 'GitHub'
            url "https://maven.pkg.github.com/${project.github_repo}"
            credentials {
                username getenv('GITHUB_ACTOR') as String
                password getenv('GITHUB_TOKEN') as String
            }
        }
    }
}

def static loadenv(path = ".env") {
    def env = [:]

    def file = new File(path)
    if (file.exists()) {
        file.eachLine { line ->
            def (name, value) = line.tokenize("=")
            env[name.trim()] = value.trim()
        }
    }
    return env
}

String readChangelogFromFile() {
    String changelogFilePath = './changelog.md'
    var file = new File(changelogFilePath)
    if (!file.exists()) {
        logger.warn("'%s' not found.", changelogFilePath)
        return "changelog file not found"
    }
    return file.getText('UTF-8')
}

publish.finalizedBy tasks.curseforge, tasks.modrinth

